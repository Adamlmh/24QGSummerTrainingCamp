# 第一周学习情况
## Git & GitHub
### Git
将远程仓库*克隆（clone）*至本地并把更改*推（push）*至远程仓库。
### 分支管理
**分支合并：**分支可以实现多线分工，最后将各部分工作内容*合并（merge）*，极大提高工作效率。
**冲突处理：**由于分支的独立性，在其合并时有可能引起*冲突（conflict）*，需要去做内容的取舍来换取工作的有序开展。
总之，在工作开展初期明确分工细则时非常有必要的。

## Java再学习
### 可变参数
形参格式（Object...object），即可实现任意参数方法。这与先将参数变成*数组*而后传递是差不多的，但是方便许多。
### 不可变集合

```java
List<String> list = List.of("a","b","c");

HashMap<String,String> hm = new HashMap<>();
Map<String,String> map = Map.copyof(hm);
```

### Stream流
**获取流**
单列集合直接使用默认方法；
双列集合无法直接使用，但可以间接；
数组使用Arrays中的静态方法；
零散数据使用Stream中的静态方法。
```java
list.stream();
map.keySet().stream(); map.entrySet().stream();
Arrays.straem(arr);
Stream.of(Object...object);
/*
下式可行，但是arr的元素仅限引用数据类型
如果arr中的元素是基本数据类型，那么由于可变参数的性质
则会把arr当成一个整体，这样的流输出的就是arr的地址而非元素
*/
Stream.of(arr);
```
**中间方法**
filter过滤（白名单）
limit获取前几个元素
skip跳过前几个元素
distinct元素去重（依赖hashCode和equals方法）
concat合二为一
map转型
```java
ArrayList<String> list = new ArrayList<>();
Collections.addAll(list, "张零", "张一", "张一", "张二", "张三", "张四", "张五", "张六七", "下北泽");
Stream<String> stream = list.stream()
        .filter(name -> name.startsWith("张"))//去掉 下北泽
        .filter(name -> name.length() == 2)//去掉 张六七
        .limit(7)//取前七个
        .skip(1)//跳过第一个
        .distinct();//去重
stream = Stream.concat(stream, Stream.of("张八666"));//张一 张二 张三 张四 张五 张八666
Stream.of("张八666")
        .map(s -> Integer.parseInt(s.substring(2)))
        .forEach(System.out::println);//666
```
**终结方法**
forEach遍历
count统计，返回long
toArra收集成数组
collect收集成List或Set或Map
```java
stream.forEach(System.out::println);
String[] arr = stream.toArray(String[]::new);
List<E> list = stream.collect(Collectors.toList());
Set<E> set = stream.collect(Collectors.toSet());
Map<K, V> map = stream.collect(Collectors.toMap(s->k,s->v));
```
### 方法引用
1. 引用处必须是函数式接口
2. 被引用的方法必须已经存在
3. 被引用的方法的形参和返回值需要和抽象方法一致
4. 被引用的方法的功能要满足当前需求
```java
public static void main(String[] args) {
    Integer[] arr = {3, 7, 4, 1, 5, 6, 2};
    //双冒号表示引用了Main中的subtraction静态方法
    Arrays.sort(arr, Main::subtraction);
    /*
    非静态 OtherClass::otherMethod
    本类（非静态） this::thisMethod
    父类（非静态） super::superMethod
    引用构造方法 OtherClass::new （无须返回值，所构造的类符合所需类即可）
    */
    for (Integer i : arr) {
        System.out.println(i);
    }
    }
    public static Integer subtraction(Integer o1,Integer o2){
    return o1-o2;
    }
```
### File类
File的三种构造方法
```java
String path = "文件路径";
File f1 = new File(parent, child);

String parent1 = "文件夹路径";
String child2 = "其中文件名";
File f2 = new File(parent, child);

File fParent2 = new File("文件夹路径");
String child2 = "其中文件名";
File f4 = new File(fParent2, child2);
```
File的常用成员方法
```java
//判断是否为文件夹、是否为文件、是否存在
isDirectory();
isFile();
exists();

//获取大小、绝对路径、名称
length();
getAbsolutePath();
getName();

//创建空文件、单级文件夹、多级文件夹
//文件（夹）不存在则创建成功，返回true，反之则false；如果父级路径不存在则false
createNewFile();
mkdir();
mkdirs();

//删除文件、空文件夹
delete();

//获取当前路径下的所有内容，保存在数组中
listFiles();
```
### 多线程
（*并发*是交替执行，*并行*是同时进行）

**多线程的三种实现方式**
继承Thread类
```java
/*
定义一个类MyThread，继承Thread
重写run()方法，放入需要多线程运行的代码
创建MyThread对象t
t.start()开启线程
*/
MyThread t = new MyThread();
t.start();
```
实现Runnable接口
```java
/*
定义一个类MyRun，实现Runnable接口
重写run方法
创建对象r
创建Thread对象t，传递参数为r
t.start()开启线程
*/
MyRun r = new MyRun();
Thread t = new Thread(r);
t.start();
```
实现Callable接口
```java
/*
定义一个类MyCallable，实现Callable接口
重写call方法，注意具有返回值
创建对象c
创建FutureTask对象f，传递参数为c
创建Thread对象t，传递参数为f
t.start()开启线程
f.get()得到所开线程的运行结果
*/
MyCallbale c = new MyCallable();
FutureTask f = new FutureTask(c);
Thread t = new Thread(f);
t.start();
System.out.println(f.get());
```
**常见成员方法**
```java
t = Thread.currentThread()//获取当前线程对象
String name = t.getName()//获得线程名字
t.setName(name)//设置线程名字
(static)sleep(long time)//线程休眠
int p = t.getProirity();//获取线程优先级，默认5
t.setProirity(10);//设置线程优先级，最小1，最大10
t.setDeamon(true);//设置为守护线程，当其他非守护线程结束时，守护线程亦结束
Thread.yield();//出让CPU执行权，即运行到此代码时尽可能让给其他线程运行
t.join();//插入线程，与上方法相反
```
**同步代码块和同步方法**
通过把共享数据*“锁”*起来，实现每次对共享数据的完整操作只能由一个线程执行，操作一次后才*“解锁”*，进入下一次执行权抢占。
```java
static int num = 0;//共享数据
static Object o = new Object();//static实现唯一的“锁”

@Override
public void run(){
	while(true){
		synchronized(obj){//同步代码块
		doSomething();//对共享数据的操作
		if(canBreak()) break;
		}
		doOtherThings();
	}
}

/*
同步方法，“锁”是自动分配的，无须手动设置
如果是静态方法，“锁”为当前类的字节码文件（唯一）
如果非静态，“锁”为this
*/
public static synchronized void doOtherThings(){}
```
**Lock锁**
可以创建锁对象，并且可以更改上锁和解锁的状态，修改以上的代码，可以变为
```java
static int num = 0;//共享数据
static Lock lock = ReentrantLock()//创建唯一锁

@Override
public void run(){
	while(true){
	lock.lock();
		try{
			doSomething();//对共享数据的操作
			if(canBreak()) break;
		}catch(InterrupyedException e){
			e.printStackTrace();
		}finally{//使用finally的特性，不管会不会break，都必须执行以下代码
			lock.unlock();
		}
	}
}
```
**等待唤醒机制（生产者和消费者）**
