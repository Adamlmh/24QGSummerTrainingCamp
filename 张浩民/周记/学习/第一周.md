# 第一周学习情况
## Git & GitHub
### Git
将远程仓库*克隆（clone）*至本地并把更改*推（push）*至远程仓库。
### 分支管理
**分支合并：**分支可以实现多线分工，最后将各部分工作内容*合并（merge）*，极大提高工作效率。
**冲突处理：**由于分支的独立性，在其合并时有可能引起*冲突（conflict）*，需要去做内容的取舍来换取工作的有序开展。
总之，在工作开展初期明确分工细则时非常有必要的。

## Java再学习
### 可变参数
形参格式（Object...object），即可实现任意参数方法。这与先将参数变成*数组*而后传递是差不多的，但是方便许多。
### 不可变集合

```java
List<String> list = List.of("a","b","c");

HashMap<String,String> hm = new HashMap<>();
Map<String,String> map = Map.copyof(hm);
```

### Stream流
**获取流**
单列集合直接使用默认方法；
双列集合无法直接使用，但可以间接；
数组使用Arrays中的静态方法；
零散数据使用Stream中的静态方法。
```java
list.stream();
map.keySet().stream(); map.entrySet().stream();
Arrays.straem(arr);
Stream.of(Object...object);
/*
下式可行，但是arr的元素仅限引用数据类型
如果arr中的元素是基本数据类型，那么由于可变参数的性质
则会把arr当成一个整体，这样的流输出的就是arr的地址而非元素
*/
Stream.of(arr);
```
**中间方法**
filter过滤（白名单）
limit获取前几个元素
skip跳过前几个元素
distinct元素去重（依赖hashCode和equals方法）
concat合二为一
map转型
```java
ArrayList<String> list = new ArrayList<>();
Collections.addAll(list, "张零", "张一", "张一", "张二", "张三", "张四", "张五", "张六七", "下北泽");
Stream<String> stream = list.stream()
        .filter(name -> name.startsWith("张"))//去掉 下北泽
        .filter(name -> name.length() == 2)//去掉 张六七
        .limit(7)//取前七个
        .skip(1)//跳过第一个
        .distinct();//去重
stream = Stream.concat(stream, Stream.of("张八666"));//张一 张二 张三 张四 张五 张八666
Stream.of("张八666")
        .map(s -> Integer.parseInt(s.substring(2)))
        .forEach(System.out::println);//666
```
**终结方法**
forEach遍历
count统计，返回long
toArra收集成数组
collect收集成List或Set或Map
```java
stream.forEach(System.out::println);
String[] arr = stream.toArray(String[]::new);
List<E> list = stream.collect(Collectors.toList());
Set<E> set = stream.collect(Collectors.toSet());
Map<K, V> map = stream.collect(Collectors.toMap(s->k,s->v));
```
### 方法引用
1. 引用处必须是函数式接口
2. 被引用的方法必须已经存在
3. 被引用的方法的形参和返回值需要和抽象方法一致
4. 被引用的方法的功能要满足当前需求
```java
public static void main(String[] args) {
    Integer[] arr = {3, 7, 4, 1, 5, 6, 2};
    //双冒号表示引用了Main中的subtraction静态方法
    Arrays.sort(arr, Main::subtraction);
    /*
    非静态 OtherClass::otherMethod
    本类（非静态） this::thisMethod
    父类（非静态） super::superMethod
    引用构造方法 OtherClass::new （无须返回值，所构造的类符合所需类即可）
    */
    for (Integer i : arr) {
        System.out.println(i);
    }
    }
    public static Integer subtraction(Integer o1,Integer o2){
    return o1-o2;
    }
```
### File类
File的三种构造方法
```java
String path = "文件路径";
File f1 = new File(parent, child);

String parent1 = "文件夹路径";
String child2 = "其中文件名";
File f2 = new File(parent, child);

File fParent2 = new File("文件夹路径");
String child2 = "其中文件名";
File f4 = new File(fParent2, child2);
```
File的常用成员方法
```java
//判断是否为文件夹、是否为文件、是否存在
isDirectory();
isFile();
exists();

//获取大小、绝对路径、名称
length();
getAbsolutePath();
getName();

//创建空文件、单级文件夹、多级文件夹
//文件（夹）不存在则创建成功，返回true，反之则false；如果父级路径不存在则false
createNewFile();
mkdir();
mkdirs();

//删除文件、空文件夹
delete();

//获取当前路径下的所有内容，保存在数组中
listFiles();
```
### 多线程 & JUC
（*并发*是交替执行，*并行*是同时进行）

**多线程的三种实现方式**
继承Thread类
```java
/*
定义一个类MyThread，继承Thread
重写run()方法，放入需要多线程运行的代码
创建MyThread对象t
t.start()开启线程
*/
MyThread t = new MyThread();
t.start();
```
实现Runnable接口
```java
/*
定义一个类MyRun，实现Runnable接口
重写run方法
创建对象r
创建Thread对象t，传递参数为r
t.start()开启线程
*/
MyRun r = new MyRun();
Thread t = new Thread(r);
t.start();
```
实现Callable接口
```java
/*
定义一个类MyCallable，实现Callable接口
重写call方法，注意具有返回值
创建对象c
创建FutureTask对象f，传递参数为c
创建Thread对象t，传递参数为f
t.start()开启线程
f.get()得到所开线程的运行结果
*/
MyCallbale c = new MyCallable();
FutureTask f = new FutureTask(c);
Thread t = new Thread(f);
t.start();
System.out.println(f.get());
```
**常见成员方法**
```java
t = Thread.currentThread()//获取当前线程对象
String name = t.getName()//获得线程名字
t.setName(name)//设置线程名字
(static)sleep(long time)//线程休眠
int p = t.getProirity();//获取线程优先级，默认5
t.setProirity(10);//设置线程优先级，最小1，最大10
t.setDeamon(true);//设置为守护线程，当其他非守护线程结束时，守护线程亦结束
Thread.yield();//出让CPU执行权，即运行到此代码时尽可能让给其他线程运行
t.join();//插入线程，与上方法相反
```
**同步代码块和同步方法**
通过把共享数据*“锁”*起来，实现每次对共享数据的完整操作只能由一个线程执行，操作一次后才*“解锁”*，进入下一次执行权抢占。
```java
static int num = 0;//共享数据
static Object o = new Object();//static实现唯一的“锁”

@Override
public void run(){
	while(true){
		synchronized(obj){//同步代码块
		doSomething();//对共享数据的操作
		if(canBreak()) break;
		}
		doOtherThings();
	}
}

/*
同步方法，“锁”是自动分配的，无须手动设置
如果是静态方法，“锁”为当前类的字节码文件（唯一）
如果非静态，“锁”为this
*/
public static synchronized void doOtherThings(){}
```
**Lock锁**
可以创建锁对象，并且可以更改上锁和解锁的状态，修改以上的代码，可以变为
```java
static int num = 0;//共享数据
static Lock lock = ReentrantLock()//创建唯一锁

@Override
public void run(){
	while(true){
	lock.lock();
		try{
			doSomething();//对共享数据的操作
			if(canBreak()) break;
		}catch(InterrupyedException e){
			e.printStackTrace();
		}finally{//使用finally的特性，不管会不会break，都必须执行以下代码
			lock.unlock();
		}
	}
}
```
**等待唤醒机制（生产者和消费者）**
严格地交替执行，通常由三个角色组成——生产者、消费者、平台，平台用于控制生产者和消费者的执行。常用方法有三个：（都是由锁调用和绑定）
```java
wait();//等待，直至被唤醒
notify()//随机唤醒一个线程
notifyAll()//唤醒所有线程
```
**阻塞队列机制**
也是三部分组成——生产者、消费者、队列。以下用伪代码：
```java
//创建唯一队列
ArrayBlockingQueue<E> queue = new ArrayBlockingQueue<>(num);

//Class Productor extend Thread:
this.queue = queue;//通过构造方法将唯一的queue传递进来
@Override
run(){
	queue.put(e);//会自动锁住队列,完成后解锁
}

//Class Consumer extend Thread:
this.queue = queue;
@Override
run(){
	queue.take();//同理自锁和解锁
}
```
**线程池**
*线程执行完不消失*，而是存储起来等待执行下次任务。

主要核心原理：
1. 创建一个空池子。
2. 提交任务时，池子或创建新的线程对象，任务执行完毕后，线程归还给池子。下次再提交任务时，无需创建新的线程，直接复用已有的线程即可。
3. 但是如果提交任务时池子中没有空闲线程，也无法创建新的线程，则任务排队等待。

使用工具类创建线程池：
```java
//创建一个无限容量的线程池
ExecutorService pool = Executoe.newCachedThreadPool();
//创建一个有限容量的线程池
//ExecutorService pool = Executoe.newCachedThreadPool(num);

//提交任务并执行
pool.submit(new MyRunnable());

//销毁线程池
pool.shutdown();
```
自定义线程池：
```java
/*
参数一：核心线程数（不小于零）
参数二：最大线程数（不小于核心线程数）
参数三：空闲线程的最大存活时间（不小于零）
参数四：时间单位（用TimeUnit指定）
参数五：任务队列（不能为null）
参数六：创建线程工厂（不能为null）
参数七：任务的拒绝策略（不能为null）
*/
ExecutorService pool = new ThreadPoolExecutor(
		3,//核心线程数
		6,//最大线程数
		60,//空闲线程的最大存活时间
		TimeUnit.SECONDS,//时间单位
		new ArrayBlockingQueue<>(),//任务队列
		Executors.defaultThreadFactory(),//创建线程工厂
		new ThreadPoolExecutor.AbortPolicy());//任务的拒绝策略
pool.submit(new MyRunnable());
```
注意，当不断地提交任务时，有三个临界点：
1. 当核心线程满时，再提交任务会进入队列排队
2. 当队伍满时，会创建临时线程
3. 当临时线程满时，会触发任务拒绝策略

**最大并行数 以及 合理设置线程池**
最大并行数可由工具类方法获取
```java
int count = Runtime.getRuntime().availableProcessors();
```
线程池设置分为两种情况：
1. CPU密集计算
此时线程池设置为“最大并行数+1”
2. I/O密集计算
最大并行数 * 期望CPU利用率 * （总时间 / CPU计算时间）
### 反射
反射允许对成员变量、成员方法和构造方法的信息进行编程访问
**获取Class对象的三种方法**
```java
Class eClass = Class.forNmae("类名");//源文件层面
Class eClass = ExampleClass.class;//类中层面
Class eClass = ExampleClass.getClass();//运行层面
```
**获取构造方法**
```java
Constructor[] constructor = eClass.getConstructors();//获取所有公共的构造方法
Constructor[] constructor = eClass.getDeclaredConstructors();//获取所有构造方法

/*
获取单个构造方法，里面的参数为想要获取的构造方法的参数的类型和数量。
例如e的一个构造方法为
private e(String name, int age){}
*/
Constructor constructor = eClass.getDeclaredConstructor(String.class, int.class);

constructor.setAccessible(true);//临时取消权限校验，无视private
E e = (E)constructor.newInstance("张三", 18);//亦可如此创建对象
```
**获取成员变量以及其信息**
```java
Field[] fields = eClass.getFields();
Field[] fields = eClass.getDeclaredFields();
/*
获取单个成员变量，参数为成员变量的名字（String）
例如，在e中存在
public String name = "张三";
private int age = 19;
*/
Field field = eClass.getField("name");//权限不够，不能获取private变量age
Field field = eClass.getDeclaredField("age");

String fieldName = getName();//获取变量名
Class<?> fieldType = field.getType();//获取数据类型

/*
可以对指定对象的变量的值进行更改，
同理如果是private变量则需要临时取消校验
以下为对e的age进行赋值，赋值为99
*/
field.setAccessible(true);
field.set(e,99)；//age=19 -> age=99
```
**获取成员方法以及参数**
```java
Method[] methods = eClass.getMethods();
Method[] methods = eClass.getDeclaredMethods();
Method method = eClass.getMethod(String name, Class<?>...parametertype);
Method method = eClass.getDeclaredMethod(String name, Class<?>...parametertype);

int modifier = method.getModifiers();//获得方法的修饰符
Parameter[] parameters = method.getParameters();//获得形参
Class[] exceptionTypes = method.getExceptionTypes();//获得可抛出的异常

/*
在e中存在方法
private int changeAge(int newAge){
	int oldAge = this.age;
	this.age = newAge;
	return oldAge;
}
现在展示如何通过反射获取方法并调用的代码
*/
Method method = eClass.getDeclaredMethod("changeAge",int.class);
method.setAccessible(true);//同理
int oldAge;
oldAge = (int) method.invoke(e,99);
```
## 设计模式
### 设计模式的六大原则
+ **开闭原则（Open Close Principle）**
开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
+ **里氏代换原则（Liskov Substitution Principle）**
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

+ **依赖倒转原则（Dependence Inversion Principle）**
这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
+ **接口隔离原则（Interface Segregation Principle）**
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
+ **迪米特法则，又称最少知道原则（Demeter Principle）**
最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
+ **合成复用原则（Composite Reuse Principle）**
合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。
### 单列模式
一个类只有一个实例，并提供一个全局访问点来获取这个实例。这种模式通常用于控制对象的数量，避免多重实例化带来的问题，如资源竞争和一致性维护等。
+ 饿汉式：程序加载即实例化，如果运行过程中不使用的情况下或造成内存浪费。
```java
public class HungrySingleton {
    private static HungrySingleton instance = new HungrySingleton();
    private HungrySingleton() {}
    public static HungrySingleton getInstance() {
        return instance;
    }
}
```
+ 懒汉式：饿汉式的补丁版，第一次被获取时才加载实例。
```java
public class LazySingleton {
    private static volatile LazySingleton instance = null;
    private LazySingleton() {}
    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```
### 观察者模式
同步更新，故对于多线程这类异步执行的行为会有问题。通过注册观察者，实现类似监听的效果。
最好是能够定义抽象主题接口和抽象观察接口，方便开发和维护。

```java
// 抽象主题
interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

// 具体主题
class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    
    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }
    
    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    
    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(this);
        }
    }
}

// 抽象观察者
interface Observer {
    void update(Subject subject);
}

// 具体观察者
class ConcreteObserver implements Observer {
    @Override
    public void update(Subject subject) {
        // 更新操作
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        Subject subject = new ConcreteSubject();
        Observer observer = new ConcreteObserver();
        
        subject.registerObserver(observer);
        subject.notifyObservers(); // 通知观察者更新
    }
}
```
## 框架
### Glide
**添加依赖**
implementation ("com.github.bumptech.glide:glide:4.16.0")
**基本使用方法**
```java
//创建。优先级fallback > error > placeholder
Glide.with(context)
	.load(url)//可以是resourceId、url、uri、drawable、file等
	.placeholder(R.drawable.placeholder)//占位符，在图片未加载出来的时候显示
	.error(R.drawable.error)//在图片永久加载失败时显示
	.fallback(R.drawable.fallback)//url为null或获取失败时显示
	.into(yourImageView);
	
//销毁。如果context销毁则亦销毁
Glide.with(context).clear(yourImageView);
```
**请求选项**
Glide中的大部分设置项都可以直接应用在 Glide.with() 返回的 RequestBuilder 对象上。
可用的选项包括但不限于：
+ 占位符(Placeholders)
+ 转换(Transformations)
+ 缓存策略(Caching Strategies)
+ 组件特有的设置项，例如编码质量，或Bitmap的解码配置等。
```java
RequestOptions cropOptions = new RequestOptions().centerCrop(Context);
Glide.with(context)
	.load(url)
	.apply(cropOptions)
	.into(yourImageView);
```
**过度选项**
TranslationOptions
**RequestBuilder**
使用RequestBuilder可以指定
+ 加载的资源的类型
+ 加载的资源地址（url / model）
+ 最终加载到的View
+ 想应用的RequestOption对象
+ 想应用的TranslationOption对象
+ 想加载的缩略图thumbnail()
```java
//二选一
RequestBuilder<Drawable> requestBuilder = Glide.with(context).asDrawable();
RequestBuilder<Drawable> requestBuilder = Glide.with(context).load(url);
```