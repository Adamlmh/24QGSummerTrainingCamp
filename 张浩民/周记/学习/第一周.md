# 第一周学习情况
## Git & GitHub
### Git
将远程仓库*克隆（clone）*至本地并把更改*推（push）*至远程仓库。
### 分支管理
**分支合并：**分支可以实现多线分工，最后将各部分工作内容*合并（merge）*，极大提高工作效率。
**冲突处理：**由于分支的独立性，在其合并时有可能引起*冲突（conflict）*，需要去做内容的取舍来换取工作的有序开展。
总之，在工作开展初期明确分工细则时非常有必要的。

## Java再学习
### 可变参数
形参格式（Object...object），即可实现任意参数方法。这与先将参数变成*数组*而后传递是差不多的，但是方便许多。
### 不可变集合

```java
List<String> list = List.of("a","b","c");

HashMap<String,String> hm = new HashMap<>();
Map<String,String> map = Map.copyof(hm);
```

### Stream流
**获取流**
单列集合直接使用默认方法；
双列集合无法直接使用，但可以间接；
数组使用Arrays中的静态方法；
零散数据使用Stream中的静态方法。
```java
list.stream();
map.keySet().stream(); map.entrySet().stream();
Arrays.straem(arr);
Stream.of(Object...object);
/*
下式可行，但是arr的元素仅限引用数据类型
如果arr中的元素是基本数据类型，那么由于可变参数的性质
则会把arr当成一个整体，这样的流输出的就是arr的地址而非元素
*/
Stream.of(arr);
```
**中间方法**
filter过滤（白名单）
limit获取前几个元素
skip跳过前几个元素
distinct元素去重（依赖hashCode和equals方法）
concat合二为一
map转型
```java
ArrayList<String> list = new ArrayList<>();
Collections.addAll(list, "张零", "张一", "张一", "张二", "张三", "张四", "张五", "张六七", "下北泽");
Stream<String> stream = list.stream()
        .filter(name -> name.startsWith("张"))//去掉 下北泽
        .filter(name -> name.length() == 2)//去掉 张六七
        .limit(7)//取前七个
        .skip(1)//跳过第一个
        .distinct();//去重
stream = Stream.concat(stream, Stream.of("张八666"));//张一 张二 张三 张四 张五 张八666
Stream.of("张八666")
        .map(s -> Integer.parseInt(s.substring(2)))
        .forEach(System.out::println);//666
```
**终结方法**
forEach遍历
count统计，返回long
toArra收集成数组
collect收集成List或Set或Map
```java
stream.forEach(System.out::println);
String[] arr = stream.toArray(String[]::new);
List<E> list = stream.collect(Collectors.toList());
Set<E> set = stream.collect(Collectors.toSet());
Map<K, V> map = stream.collect(Collectors.toMap(s->k,s->v));
```
### 方法引用
1. 引用处必须是函数式接口
2. 被引用的方法必须已经存在
3. 被引用的方法的形参和返回值需要和抽象方法一致
4. 被引用的方法的功能要满足当前需求
```java
public static void main(String[] args) {
    Integer[] arr = {3, 7, 4, 1, 5, 6, 2};
    //双冒号表示引用了Main中的subtraction静态方法
    Arrays.sort(arr, Main::subtraction);
    /*
    非静态 OtherClass::otherMethod
    本类（非静态） this::thisMethod
    父类（非静态） super::superMethod
    引用构造方法 OtherClass::new （无须返回值，所构造的类符合所需类即可）
    */
    for (Integer i : arr) {
        System.out.println(i);
    }
    }
    public static Integer subtraction(Integer o1,Integer o2){
    return o1-o2;
    }
```
### File类
File的三种构造方法
```java
String path = "文件路径";
File f1 = new File(parent, child);

String parent1 = "文件夹路径";
String child2 = "其中文件名";
File f2 = new File(parent, child);

File fParent2 = new File("文件夹路径");
String child2 = "其中文件名";
File f4 = new File(fParent2, child2);
```
File的常用成员方法
```java
//判断是否为文件夹、是否为文件、是否存在
isDirectory();
isFile();
exists();

//获取大小、绝对路径、名称
length();
getAbsolutePath();
getName();

//创建空文件、单级文件夹、多级文件夹
//文件（夹）不存在则创建成功，返回true，反之则false；如果父级路径不存在则false
createNewFile();
mkdir();
mkdirs();

//删除文件、空文件夹
delete();

//获取当前路径下的所有内容，保存在数组中
listFiles();
```
### 多线程 & JUC
（*并发*是交替执行，*并行*是同时进行）

**多线程的三种实现方式**
继承Thread类
```java
/*
定义一个类MyThread，继承Thread
重写run()方法，放入需要多线程运行的代码
创建MyThread对象t
t.start()开启线程
*/
MyThread t = new MyThread();
t.start();
```
实现Runnable接口
```java
/*
定义一个类MyRun，实现Runnable接口
重写run方法
创建对象r
创建Thread对象t，传递参数为r
t.start()开启线程
*/
MyRun r = new MyRun();
Thread t = new Thread(r);
t.start();
```
实现Callable接口
```java
/*
定义一个类MyCallable，实现Callable接口
重写call方法，注意具有返回值
创建对象c
创建FutureTask对象f，传递参数为c
创建Thread对象t，传递参数为f
t.start()开启线程
f.get()得到所开线程的运行结果
*/
MyCallbale c = new MyCallable();
FutureTask f = new FutureTask(c);
Thread t = new Thread(f);
t.start();
System.out.println(f.get());
```
**常见成员方法**
```java
t = Thread.currentThread()//获取当前线程对象
String name = t.getName()//获得线程名字
t.setName(name)//设置线程名字
(static)sleep(long time)//线程休眠
int p = t.getProirity();//获取线程优先级，默认5
t.setProirity(10);//设置线程优先级，最小1，最大10
t.setDeamon(true);//设置为守护线程，当其他非守护线程结束时，守护线程亦结束
Thread.yield();//出让CPU执行权，即运行到此代码时尽可能让给其他线程运行
t.join();//插入线程，与上方法相反
```
**同步代码块和同步方法**
通过把共享数据*“锁”*起来，实现每次对共享数据的完整操作只能由一个线程执行，操作一次后才*“解锁”*，进入下一次执行权抢占。
```java
static int num = 0;//共享数据
static Object o = new Object();//static实现唯一的“锁”

@Override
public void run(){
	while(true){
		synchronized(obj){//同步代码块
		doSomething();//对共享数据的操作
		if(canBreak()) break;
		}
		doOtherThings();
	}
}

/*
同步方法，“锁”是自动分配的，无须手动设置
如果是静态方法，“锁”为当前类的字节码文件（唯一）
如果非静态，“锁”为this
*/
public static synchronized void doOtherThings(){}
```
**Lock锁**
可以创建锁对象，并且可以更改上锁和解锁的状态，修改以上的代码，可以变为
```java
static int num = 0;//共享数据
static Lock lock = ReentrantLock()//创建唯一锁

@Override
public void run(){
	while(true){
	lock.lock();
		try{
			doSomething();//对共享数据的操作
			if(canBreak()) break;
		}catch(InterrupyedException e){
			e.printStackTrace();
		}finally{//使用finally的特性，不管会不会break，都必须执行以下代码
			lock.unlock();
		}
	}
}
```
**等待唤醒机制（生产者和消费者）**
严格地交替执行，通常由三个角色组成——生产者、消费者、平台，平台用于控制生产者和消费者的执行。常用方法有三个：（都是由锁调用和绑定）
```java
wait();//等待，直至被唤醒
notify()//随机唤醒一个线程
notifyAll()//唤醒所有线程
```
**阻塞队列机制**
也是三部分组成——生产者、消费者、队列。以下用伪代码：
```java
//创建唯一队列
ArrayBlockingQueue<E> queue = new ArrayBlockingQueue<>(num);

//Class Productor extend Thread:
this.queue = queue;//通过构造方法将唯一的queue传递进来
@Override
run(){
	queue.put(e);//会自动锁住队列,完成后解锁
}

//Class Consumer extend Thread:
this.queue = queue;
@Override
run(){
	queue.take();//同理自锁和解锁
}
```
**线程池**
*线程执行完不消失*，而是存储起来等待执行下次任务。

主要核心原理：
1. 创建一个空池子。
2. 提交任务时，池子或创建新的线程对象，任务执行完毕后，线程归还给池子。下次再提交任务时，无需创建新的线程，直接复用已有的线程即可。
3. 但是如果提交任务时池子中没有空闲线程，也无法创建新的线程，则任务排队等待。

使用工具类创建线程池：
```java
//创建一个无限容量的线程池
ExecutorService pool = Executoe.newCachedThreadPool();
//创建一个有限容量的线程池
//ExecutorService pool = Executoe.newCachedThreadPool(num);

//提交任务并执行
pool.submit(new MyRunnable());

//销毁线程池
pool.shutdown();
```
自定义线程池：
```java
/*
参数一：核心线程数（不小于零）
参数二：最大线程数（不小于核心线程数）
参数三：空闲线程的最大存活时间（不小于零）
参数四：时间单位（用TimeUnit指定）
参数五：任务队列（不能为null）
参数六：创建线程工厂（不能为null）
参数七：任务的拒绝策略（不能为null）
*/
ExecutorService pool = new ThreadPoolExecutor(
		3,//核心线程数
		6,//最大线程数
		60,//空闲线程的最大存活时间
		TimeUnit.SECONDS,//时间单位
		new ArrayBlockingQueue<>(),//任务队列
		Executors.defaultThreadFactory(),//创建线程工厂
		new ThreadPoolExecutor.AbortPolicy());//任务的拒绝策略
pool.submit(new MyRunnable());
```
注意，当不断地提交任务时，有三个临界点：
1. 当核心线程满时，再提交任务会进入队列排队
2. 当队伍满时，会创建临时线程
3. 当临时线程满时，会触发任务拒绝策略

**最大并行数 以及 合理设置线程池**
最大并行数可由工具类方法获取
```java
int count = Runtime.getRuntime().availableProcessors();
```
线程池设置分为两种情况：
1. CPU密集计算
此时线程池设置为“最大并行数+1”
2. I/O密集计算
最大并行数 * 期望CPU利用率 * （总时间 / CPU计算时间）
### 反射
反射允许对成员变量、成员方法和构造方法的信息进行编程访问
获取Class对象的三种方法
```java
Class eClass = Class.forNmae("类名");//源文件层面
Class eClass = ExampleClass.class;//类中层面
Class eClass = ExampleClass.getClass();//运行层面
```
获取构造方法
```java
Constructor[] constructor = eClass.getConstructors();//获取所有公共的构造方法
Constructor[] constructor = eClass.getDeclaredConstructors();//获取所有构造方法

/*
获取单个构造方法，里面的参数为想要获取的构造方法的参数的类型和数量。
例如e的一个构造方法为
private e(String name, int age){}
*/
Constructor constructor = eClass.getDeclaredConstructor(String.class, int.class);

constructor.setAccessible(true);//临时取消权限校验，无视private
E e = (E)constructor.newInstance("张三", 18);//亦可如此创建对象
```
获取成员变量以及其信息
```java
Field[] fields = eClass.getFields();
Field[] fields = eClass.getDeclaredFields();
/*
获取单个成员变量，参数为成员变量的名字（String）
例如，在e中存在
public String name = "张三";
private int age = 19;
*/
Field field = eClass.getField("name");//权限不够，不能获取private变量age
Field field = eClass.getDeclaredField("age");

String fieldName = getName();//获取变量名
Class<?> fieldType = field.getType();//获取数据类型

/*
可以对指定对象的变量的值进行更改，
同理如果是private变量则需要临时取消校验
以下为对e的age进行赋值，赋值为99
*/
field.setAccessible(true);
field.set(e,99)；//age=19 -> age=99
```
获取成员方法以及参数
```java
Method[] methods = eClass.getMethods();
Method[] methods = eClass.getDeclaredMethods();
Method method = eClass.getMethod(String name, Class<?>...parametertype);
Method method = eClass.getDeclaredMethod(String name, Class<?>...parametertype);

int modifier = method.getModifiers();//获得方法的修饰符
Parameter[] parameters = method.getParameters();//获得形参
Class[] exceptionTypes = method.getExceptionTypes();//获得可抛出的异常

/*
在e中存在方法
private int changeAge(int newAge){
	int oldAge = this.age;
	this.age = newAge;
	return oldAge;
}
现在展示如何通过反射获取方法并调用的代码
*/
Method method = eClass.getDeclaredMethod("changeAge",int.class);
method.setAccessible(true);//同理
int oldAge;
oldAge = (int) method.invoke(e,99);
```